{"id":90,"distPath":"docs/.vitepress/dist/reference/airnode/latest/specifications/airnode-abi.html","indexPath":"docs/.vitepress/search-files/reference/airnode/latest/specifications/airnode-abi.json","docSet":"/reference/airnode/latest/","url":"/reference/airnode/latest/specifications/airnode-abi.html","content":"  üìÇ¬†Reference ‚Üí Airnode ‚Üí v1.0 ‚Üí Specifications  Airnode ABI [#] (#frontmatter-title)  ==  [Contract application binary interface (ABI)] (https://docs.soliditylang.org/en/v0.6.12/abi-spec.html) is used to encode different types of data while interacting with Ethereum contracts. As a result, both Solidity and modules such as [web3.js] (https://web3js.readthedocs.io/) and [ethers.js] (https://docs.ethers.io/) treat ABI encoding‚Äìdecoding functionality as a first-class citizen. This makes using contract ABI for encoding API call parameters a very attractive option. Although encoding API call parameters using contract ABI has many advantages, it cannot be used for this purpose directly. Quoting from the [Solidity docs] (https://docs.soliditylang.org/en/v0.6.12/abi-spec.html) : The encoding is not self describing and thus requires a schema in order to decode. This means that when passing API call parameters (of type bytes), you would also need to pass a list of the types for these parameters, which is cumbersome and it is not clear how these types would be encoded. As a solution, Airnode uses Airnode ABI specifications, an extension of contract ABI specifications that includes a header that keeps the schema.  Header [#] (#header)  -  The Airnode ABI specifications header is of type bytes32 and acts as the schema (i.e., describes the types of the API call parameters). The header is encoded in UTF-8 for ease of use. Here is an example: &quot;1BSasbiuBa&quot;  1 The first character, 1, represents the encoding version. Each following character represents the type of an API call parameter.  Type encodings [#] (#type-encodings)   The types are encoded in UTF-8 characters as follows: B: bytes b: bytes32 S: string s: string32 a: address u: uint256 i: int256 f: bool  1 2 3 4 5 6 7 8 Note that dynamically-sized types are represented with uppercase letters and statically-sized types are represented with lowercase letters. Another thing to notice is that s represents string32, but this is an artificial type and it is not part of [solidity types] (https://docs.soliditylang.org/en/latest/types.html) . This type is instead represented on chain as bytes32. The reasons for this are explained in depth in [string32 details] (./airnode-abi-specifications.html#string32) section.  Encoding format [#] (#encoding-format)  ----  Airnode ABI specifications has the following encoding format (which is somewhat similar to [SDS] (https://github.com/antirez/sds) ): [----][-] Header of type bytes32 API call parameter name‚Äìvalue pairs  1 2 Note that each API call parameter is preceded with a name of type bytes32.  Example encoding [#] (#example-encoding)  -  To encode the following API call parameters json{ &quot;MyFirstBytes&quot;: &quot;0x1234&quot;, &quot;MyString&quot;: &quot;1234&quot;, &quot;MyFirstAddress&quot;: &quot;0x0000000000000000000000000000000000001234&quot;, &quot;MyString32&quot;: &quot;1234&quot;, &quot;MyBytes32&quot;: &quot;0x68656c6c6f000000000000000000000000000000000000000000000000000000&quot;, &quot;MyInt256&quot;: &quot;-1234&quot;, &quot;MyUint256&quot;: &quot;1234&quot;, &quot;MySecondBytes&quot;: &quot;0x5678&quot;, &quot;MySecondAddress&quot;: &quot;0x0000000000000000000000000000000000005678&quot; }  1 2 3 4 5 6 7 8 9 10 11 you would do this in a requester contract as: soliditybytes memory parameters = abi.encode( bytes32(&quot;1BSasbiuBa&quot;), bytes32(&quot;MyFirstBytes&quot;), bytes(hex&quot;1234&quot;), bytes32(&quot;MyString&quot;), &quot;1234&quot;, bytes32(&quot;MyFirstAddress&quot;), 0x0000000000000000000000000000000000001234, bytes32(&quot;MyString32&quot;), bytes32(&quot;1234&quot;), bytes32(&quot;MyBytes32&quot;), 0x68656c6c6f000000000000000000000000000000000000000000000000000000, bytes32(&quot;MyInt256&quot;), -1234, bytes32(&quot;MyUint256&quot;), 1234, bytes32(&quot;MySecondBytes&quot;), bytes(hex&quot;5678&quot;), bytes32(&quot;MySecondAddress&quot;), 0x0000000000000000000000000000000000005678 );  1 2 3 4 5 6 7 8 9 10 11 12 Note that you do not need to add an external library to the contract, and abi.encode() is fairly cheap in terms of gas usage (compared to alternative encoding methods).  Example decoding [#] (#example-decoding)  -  If you know the schema of the encoded parameters, then decode them on-chain. For example, if the schema is (bytes,string): solidity( bytes32 header, bytes32 name1, bytes memory value1, bytes32 name2, string memory value2 ) = abi.decode(parameters, (bytes32,bytes32,bytes,bytes32,string));  1 2 3 4 5 Note that this disregards the header and hard codes the schema into the code. It is also possible to parse the header on-chain and decode accordingly, yet that would be a lot more complex.  Details [#] (#details)  ---   string32 [#] (#string32)   A parameter being of type string32 (encoded as characted s in the ABI specification schema header) implies that the parameter is UTF-8 encoded text. For example, if the parameter is 0x68656c6c6f000000000000000000000000000000000000000000000000000000  1 Airnode will decode it as &quot;hello&quot;  1 and feed that to the API, which is what the user would want to do in most cases. This becomes a problem if the parameter is not encoded text, but for example a hash such as: 0x1fd36c61981313c0c155d33ffac0325bd7c00d21d52442981bb13d2fa13e8f71  1 If this hash is encoded as a string32 type, Airnode will decode it as: \u001f√ìla¬ò\u0013\u0013√Ä√ÅU√ì?√∫√Ä2[√ó√Ä !√ï$B¬ò\u001b¬±=/¬°&gt;¬èq  1 2 which is probably not what the user is looking for. For these use cases, the user should use the [bytes32] (./airnode-abi-specifications.html#bytes32) type instead.  bytes32 [#] (#bytes32)   To encode a bytes32 hash on chain, use the bytes32 type which is represented by b in the ABI header schema. soliditybytes memory parameters = abi.encode( bytes32(&quot;1b&quot;), bytes32(&quot;MyBytes32&quot;), 0x1fd36c61981313c0c155d33ffac0325bd7c00d21d52442981bb13d2fa13e8f71, );  1 2 3 4 When decoded by Airnode, the value would be the hash itself: &quot;0x1fd36c61981313c0c155d33ffac0325bd7c00d21d52442981bb13d2fa13e8f71&quot;  1 If you want to store 32 byte string values on chain, use the [string32] (./airnode-abi-specifications.html#string32) type instead.  bool [#] (#bool)   The bool type, encoded as charatcter f using the ABI specification schema can be used to encode a boolean value. The header symbol is f, because character b was already reserved for bytes encodings. So we chose letter f as bool values are commonly used to represent &quot;boolean flags&quot;.  Omitted types [#] (#omitted-types)   array and tuple are omitted because they are not suitable to be used as API parameters. uint8-uint128, int8-int128, bytes1-bytes31 are omitted because they are padded to 32 bytes by the ABI encoder anyway (meaning that the user should simply typecast these to the 32-byte versions).  Size limit [#] (#size-limit)   The header can encode up to 31 parameters (and 1 byte is used to encode the encoding version). This is far more than what would be needed in practice, and thus is tolerated to avoid a more complex solution.  Padding [#] (#padding)   [Strict encoding mode] (https://docs.soliditylang.org/en/v0.6.12/abi-spec.html#strict-encoding-mode) is used so that you can decode the values later on. This means that each parameter will be padded with zeros to complete them to 32 bytes. Although this padding increases gas costs, ABI encoding/decoding functions being cheap balances this. Furthermore, the [template] (./../../concepts/template.html) pattern used in the protocols allows for the referencing of these encoded parameters without explicitly passing them in requests, making the increased cost induced by padding irrelevant in most cases.  @api3/airnode-abi [#] (#api3-airnode-abi)  --  Encode and decode parameters with the [airnode-abi] (./../packages/airnode-abi.html) package. jsimport { encode } from &#39;@api3/airnode-abi&#39;; import { decode } from &#39;@api3/airnode-abi&#39;; const parameters = [ { type: &#39;string32&#39;, name: &#39;from&#39;, value: &#39;ETH&#39; }, { type: &#39;uint256&#39;, name: &#39;amount&#39;, value: &#39;100000&#39; }, ]; const encodedData = encode(parameters); const decoded = decode(encodedData); console.log(&#39;ENCODED:&#39;, encodedData); console.log(&#39;\\nDECODED:&#39;, decoded);  1 2 3 4 5 6 7 8 9 10 11 12 See the package doc [airnode-abi] (./../packages/airnode-abi.html) for more information on how to encode and decode with Airnode ABI off-chain. Also see code samples in the [examples] (https://github.com/api3dao/airnode/tree/v0.8/packages/airnode-examples) package. --- [request-utils.ts] (https://github.com/api3dao/airnode/blob/v0.8/packages/airnode-examples/integrations/coingecko/request-utils.ts#L8)  [Previous pageOracle Integration (OIS)] (/reference/airnode/latest/specifications/ois.html)  [Next pageReserved Parameters] (/reference/airnode/latest/specifications/reserved-parameters.html)  "}